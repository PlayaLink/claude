#!/bin/bash
#
# sync.sh
# Synchronize source-of-truth AI guidelines from .ai-guidelines/ into
# tool-specific outputs for each git repository in this workspace.
#
# Generated outputs per repo:
# - AGENTS.md (Codex block)
# - .cursor/rules/*.mdc
# - .claude/rules/*.md
# - .claude/skills/*
# - .claude/commands/*.md
# - .agents/skills/*
# - .ai-guidelines-manifest
#

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
DEFAULT_WORKSPACE_DIR="$(dirname "$SCRIPT_DIR")"

WORKSPACE_DIR="${AI_GUIDELINES_WORKSPACE_DIR:-$DEFAULT_WORKSPACE_DIR}"
SHARED_GUIDELINES_DIR="${AI_GUIDELINES_SHARED_DIR:-$SCRIPT_DIR}"
INCLUDE_WORKSPACE_ROOT="${AI_GUIDELINES_INCLUDE_WORKSPACE_ROOT:-0}"

WORKSPACE_DIR="$(cd "$WORKSPACE_DIR" && pwd)"
SHARED_GUIDELINES_DIR="$(cd "$SHARED_GUIDELINES_DIR" && pwd)"

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m'

CODEX_BLOCK_START="<!-- BEGIN: AI GUIDELINES SYNC (generated) -->"
CODEX_BLOCK_END="<!-- END: AI GUIDELINES SYNC (generated) -->"
LEGACY_CODEX_BLOCK_START="<!-- BEGIN: AI RULES SYNC (generated) -->"
LEGACY_CODEX_BLOCK_END="<!-- END: AI RULES SYNC (generated) -->"

rel_from_workspace() {
  local abs_path="$1"
  if [ "$abs_path" = "$WORKSPACE_DIR" ]; then
    echo "."
    return
  fi
  if [[ "$abs_path" == "$WORKSPACE_DIR"/* ]]; then
    echo "${abs_path#"$WORKSPACE_DIR"/}"
  else
    echo "$abs_path"
  fi
}

list_markdown_files() {
  local dir="$1"
  [ -d "$dir" ] || return 0
  find "$dir" -maxdepth 1 -type f -name "*.md" | sort
}

list_child_dirs() {
  local dir="$1"
  [ -d "$dir" ] || return 0
  find "$dir" -mindepth 1 -maxdepth 1 -type d | sort
}

add_always_apply() {
  local input_file="$1"
  local output_file="$2"
  local value="${3:-true}"

  if head -1 "$input_file" | grep -q "^---$"; then
    if grep -q "alwaysApply:" "$input_file"; then
      cp "$input_file" "$output_file"
    else
      awk -v val="$value" '
        NR==1 { print; next }
        /^---$/ && !added { print "alwaysApply: " val; added=1 }
        { print }
      ' "$input_file" > "$output_file"
    fi
  else
    {
      echo "---"
      echo "alwaysApply: $value"
      echo "---"
      echo ""
      cat "$input_file"
    } > "$output_file"
  fi
}

strip_frontmatter() {
  local input_file="$1"

  if head -1 "$input_file" | grep -q "^---$"; then
    awk '
      NR==1 && $0=="---" { in_frontmatter=1; next }
      in_frontmatter && $0=="---" { in_frontmatter=0; next }
      in_frontmatter { next }
      { print }
    ' "$input_file"
  else
    cat "$input_file"
  fi
}

append_codex_guideline() {
  local file="$1"
  local source_path="$2"
  local output_file="$3"
  local guideline_name
  guideline_name="$(basename "$file" .md)"

  {
    echo "#### \`$guideline_name\`"
    echo "_Source: \`$source_path\`_"
    echo ""
    strip_frontmatter "$file"
    echo ""
  } >> "$output_file"
}

build_codex_block() {
  local project_rel="$1"
  local project_guidelines_dir="$2"
  local output_file="$3"

  CODEX_GUIDELINE_COUNT=0
  local global_written=0
  local conditional_written=0

  {
    echo "$CODEX_BLOCK_START"
    echo "## AI Guidelines (Synced)"
    echo ""
    echo "_Generated by \`.ai-guidelines/sync.sh\`._"
    echo "_Edit source guidelines in \`.ai-guidelines/\`; do not edit this block directly._"
    echo ""
    echo "### Global Guidelines (Always Apply)"
    echo ""
  } > "$output_file"

  while IFS= read -r file; do
    [ -f "$file" ] || continue
    local base
    base="$(basename "$file" .md)"
    if [ -f "$project_guidelines_dir/global/$base.md" ]; then
      continue
    fi
    append_codex_guideline "$file" ".ai-guidelines/global/$base.md" "$output_file"
    global_written=1
    CODEX_GUIDELINE_COUNT=$((CODEX_GUIDELINE_COUNT + 1))
  done < <(list_markdown_files "$SHARED_GUIDELINES_DIR/global")

  while IFS= read -r file; do
    [ -f "$file" ] || continue
    local base
    base="$(basename "$file" .md)"
    append_codex_guideline "$file" "$project_rel/.ai-guidelines/global/$base.md" "$output_file"
    global_written=1
    CODEX_GUIDELINE_COUNT=$((CODEX_GUIDELINE_COUNT + 1))
  done < <(list_markdown_files "$project_guidelines_dir/global")

  if [ "$global_written" -eq 0 ]; then
    echo "- None" >> "$output_file"
    echo "" >> "$output_file"
  fi

  {
    echo "### Conditional Guidelines (Apply When Relevant)"
    echo ""
  } >> "$output_file"

  while IFS= read -r file; do
    [ -f "$file" ] || continue
    local base
    base="$(basename "$file" .md)"
    if [ -f "$project_guidelines_dir/conditional/$base.md" ]; then
      continue
    fi
    append_codex_guideline "$file" ".ai-guidelines/conditional/$base.md" "$output_file"
    conditional_written=1
    CODEX_GUIDELINE_COUNT=$((CODEX_GUIDELINE_COUNT + 1))
  done < <(list_markdown_files "$SHARED_GUIDELINES_DIR/conditional")

  while IFS= read -r file; do
    [ -f "$file" ] || continue
    local base
    base="$(basename "$file" .md)"
    append_codex_guideline "$file" "$project_rel/.ai-guidelines/conditional/$base.md" "$output_file"
    conditional_written=1
    CODEX_GUIDELINE_COUNT=$((CODEX_GUIDELINE_COUNT + 1))
  done < <(list_markdown_files "$project_guidelines_dir/conditional")

  if [ "$conditional_written" -eq 0 ]; then
    echo "- None" >> "$output_file"
    echo "" >> "$output_file"
  fi

  {
    echo "$CODEX_BLOCK_END"
    echo ""
  } >> "$output_file"
}

upsert_codex_agents() {
  local agents_file="$1"
  local generated_block_file="$2"
  local temp_file sanitized_file
  temp_file="$(mktemp)"
  sanitized_file="$(mktemp)"

  if [ -f "$agents_file" ]; then
    # Remove legacy AI RULES block if present so we keep a single generated block format.
    if grep -qF "$LEGACY_CODEX_BLOCK_START" "$agents_file" && grep -qF "$LEGACY_CODEX_BLOCK_END" "$agents_file"; then
      awk -v start="$LEGACY_CODEX_BLOCK_START" -v end="$LEGACY_CODEX_BLOCK_END" '
        BEGIN { skipping = 0 }
        $0 == start { skipping = 1; next }
        $0 == end { skipping = 0; next }
        skipping != 1 { print }
      ' "$agents_file" > "$sanitized_file"
    else
      cp "$agents_file" "$sanitized_file"
    fi

    if grep -qF "$CODEX_BLOCK_START" "$sanitized_file" && grep -qF "$CODEX_BLOCK_END" "$sanitized_file"; then
      awk -v start="$CODEX_BLOCK_START" -v end="$CODEX_BLOCK_END" -v block_file="$generated_block_file" '
        BEGIN {
          while ((getline line < block_file) > 0) {
            block = block line ORS
          }
          close(block_file)
          replaced = 0
          skipping = 0
        }
        $0 == start {
          printf "%s", block
          skipping = 1
          replaced = 1
          next
        }
        $0 == end {
          skipping = 0
          next
        }
        skipping != 1 { print }
        END {
          if (replaced == 0) {
            if (NR > 0) print ""
            printf "%s", block
          }
        }
      ' "$sanitized_file" > "$temp_file"
    else
      {
        cat "$sanitized_file"
        echo ""
        cat "$generated_block_file"
      } > "$temp_file"
    fi
  else
    cat "$generated_block_file" > "$temp_file"
  fi

  mv "$temp_file" "$agents_file"
  rm -f "$sanitized_file"
}

cleanup_previous_generated() {
  local project_dir="$1"
  local manifest_file="$2"

  [ -f "$manifest_file" ] || return 0

  while IFS= read -r rel_path; do
    [ -n "$rel_path" ] || continue
    case "$rel_path" in
      .cursor/rules/*|.claude/rules/*|.claude/skills/*|.claude/commands/*|.agents/skills/*)
        rm -f "$project_dir/$rel_path"
        ;;
      *)
        ;;
    esac
  done < "$manifest_file"
}

prune_empty_managed_dirs() {
  local project_dir="$1"
  for dir in \
    "$project_dir/.cursor/rules" \
    "$project_dir/.claude/rules" \
    "$project_dir/.claude/skills" \
    "$project_dir/.claude/commands" \
    "$project_dir/.agents/skills"; do
    if [ -d "$dir" ]; then
      find "$dir" -depth -type d -empty -delete
    fi
  done
}

write_manifest() {
  local project_dir="$1"
  local manifest_file="$2"
  local tmp_manifest
  tmp_manifest="$(mktemp)"

  for root in \
    ".cursor/rules" \
    ".claude/rules" \
    ".claude/skills" \
    ".claude/commands" \
    ".agents/skills"; do
    local abs_root="$project_dir/$root"
    if [ -d "$abs_root" ]; then
      find "$abs_root" -type f | sed "s|^$project_dir/||" >> "$tmp_manifest"
    fi
  done

  sort -u "$tmp_manifest" > "$manifest_file"
  rm -f "$tmp_manifest"
}

discover_projects() {
  find "$WORKSPACE_DIR" \
    \( -path "*/node_modules/*" -o -path "*/.git/*" \) -prune -o \
    \( -name ".git" -type d -o -name ".git" -type f \) -print \
    | while IFS= read -r git_path; do
        dirname "$git_path"
      done \
    | awk 'NF' \
    | sort -u
}

sync_project() {
  local project_dir="$1"
  local project_rel
  project_rel="$(rel_from_workspace "$project_dir")"

  local project_guidelines_dir="$project_dir/.ai-guidelines"
  local manifest_file="$project_dir/.ai-guidelines-manifest"

  local cursor_out="$project_dir/.cursor/rules"
  local claude_rules_out="$project_dir/.claude/rules"
  local claude_skills_out="$project_dir/.claude/skills"
  local claude_commands_out="$project_dir/.claude/commands"
  local codex_skills_out="$project_dir/.agents/skills"
  local codex_agents="$project_dir/AGENTS.md"
  local codex_block_tmp
  codex_block_tmp="$(mktemp)"

  echo -e "${BLUE}ðŸ“¦ $project_rel${NC}"

  cleanup_previous_generated "$project_dir" "$manifest_file"
  prune_empty_managed_dirs "$project_dir"

  mkdir -p \
    "$cursor_out" \
    "$claude_rules_out" \
    "$claude_skills_out" \
    "$claude_commands_out" \
    "$codex_skills_out"

  local global_count=0
  local conditional_count=0
  local skill_count=0
  local command_count=0
  local codex_count=0

  # Shared global guidelines (unless overridden by project)
  while IFS= read -r file; do
    [ -f "$file" ] || continue
    local base
    base="$(basename "$file" .md)"
    if [ -f "$project_guidelines_dir/global/$base.md" ]; then
      continue
    fi
    add_always_apply "$file" "$cursor_out/$base.mdc" "true"
    cp "$file" "$claude_rules_out/$base.md"
    global_count=$((global_count + 1))
  done < <(list_markdown_files "$SHARED_GUIDELINES_DIR/global")

  # Project global guidelines
  while IFS= read -r file; do
    [ -f "$file" ] || continue
    local base
    base="$(basename "$file" .md)"
    add_always_apply "$file" "$cursor_out/$base.mdc" "true"
    cp "$file" "$claude_rules_out/$base.md"
    global_count=$((global_count + 1))
  done < <(list_markdown_files "$project_guidelines_dir/global")

  # Shared conditional guidelines (unless overridden by project)
  while IFS= read -r file; do
    [ -f "$file" ] || continue
    local base
    base="$(basename "$file" .md)"
    if [ -f "$project_guidelines_dir/conditional/$base.md" ]; then
      continue
    fi
    add_always_apply "$file" "$cursor_out/$base.mdc" "false"
    cp "$file" "$claude_rules_out/$base.md"
    conditional_count=$((conditional_count + 1))
  done < <(list_markdown_files "$SHARED_GUIDELINES_DIR/conditional")

  # Project conditional guidelines
  while IFS= read -r file; do
    [ -f "$file" ] || continue
    local base
    base="$(basename "$file" .md)"
    add_always_apply "$file" "$cursor_out/$base.mdc" "false"
    cp "$file" "$claude_rules_out/$base.md"
    conditional_count=$((conditional_count + 1))
  done < <(list_markdown_files "$project_guidelines_dir/conditional")

  # Shared skills (unless overridden by project)
  while IFS= read -r skill_dir; do
    [ -d "$skill_dir" ] || continue
    local skill_name
    skill_name="$(basename "$skill_dir")"
    if [ -d "$project_guidelines_dir/skills/$skill_name" ]; then
      continue
    fi
    mkdir -p "$claude_skills_out/$skill_name" "$codex_skills_out/$skill_name"
    rsync -a --delete "$skill_dir/" "$claude_skills_out/$skill_name/"
    rsync -a --delete "$skill_dir/" "$codex_skills_out/$skill_name/"
    skill_count=$((skill_count + 1))
  done < <(list_child_dirs "$SHARED_GUIDELINES_DIR/skills")

  # Project skills
  while IFS= read -r skill_dir; do
    [ -d "$skill_dir" ] || continue
    local skill_name
    skill_name="$(basename "$skill_dir")"
    mkdir -p "$claude_skills_out/$skill_name" "$codex_skills_out/$skill_name"
    rsync -a --delete "$skill_dir/" "$claude_skills_out/$skill_name/"
    rsync -a --delete "$skill_dir/" "$codex_skills_out/$skill_name/"
    skill_count=$((skill_count + 1))
  done < <(list_child_dirs "$project_guidelines_dir/skills")

  # Shared commands (unless overridden by project)
  while IFS= read -r file; do
    [ -f "$file" ] || continue
    local base
    base="$(basename "$file" .md)"
    if [ -f "$project_guidelines_dir/commands/$base.md" ]; then
      continue
    fi
    cp "$file" "$claude_commands_out/$base.md"
    command_count=$((command_count + 1))
  done < <(list_markdown_files "$SHARED_GUIDELINES_DIR/commands")

  # Project commands
  while IFS= read -r file; do
    [ -f "$file" ] || continue
    local base
    base="$(basename "$file" .md)"
    cp "$file" "$claude_commands_out/$base.md"
    command_count=$((command_count + 1))
  done < <(list_markdown_files "$project_guidelines_dir/commands")

  build_codex_block "$project_rel" "$project_guidelines_dir" "$codex_block_tmp"
  codex_count="$CODEX_GUIDELINE_COUNT"
  upsert_codex_agents "$codex_agents" "$codex_block_tmp"
  rm -f "$codex_block_tmp"

  write_manifest "$project_dir" "$manifest_file"

  echo "   âœ“ Global: $global_count | Conditional: $conditional_count | Skills: $skill_count | Commands: $command_count | Codex guidelines: $codex_count"
}

echo "ðŸ”„ Syncing AI guidelines across workspace projects..."
echo ""

echo "ðŸ” Discovering git repositories..."
projects=()
while IFS= read -r project_dir; do
  projects+=("$project_dir")
done < <(discover_projects)

filtered_projects=()
for project_dir in "${projects[@]}"; do
  if [ "$project_dir" = "$WORKSPACE_DIR" ] && [ "$INCLUDE_WORKSPACE_ROOT" != "1" ]; then
    continue
  fi
  if [ "$project_dir" = "$SHARED_GUIDELINES_DIR" ] || [[ "$project_dir" == "$SHARED_GUIDELINES_DIR/"* ]]; then
    continue
  fi
  filtered_projects+=("$project_dir")
done

echo "   Found: ${#filtered_projects[@]} repos"
for project_dir in "${filtered_projects[@]}"; do
  echo "   - $(rel_from_workspace "$project_dir")"
done
echo ""

for project_dir in "${filtered_projects[@]}"; do
  sync_project "$project_dir"
done

echo ""
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
echo -e "${GREEN}âœ“ Sync complete!${NC}"
echo ""
echo "Shared source: $SHARED_GUIDELINES_DIR"
echo "Projects synced: ${#filtered_projects[@]}"
echo ""
echo -e "${YELLOW}Edit source files in .ai-guidelines/; generated outputs are managed by sync.${NC}"
